# Stubs for tortoise.models (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from tortoise.backends.base.client import BaseDBAsyncClient
from tortoise.queryset import QuerySet
from typing import Any, Hashable, Optional, Tuple, Type, TypeVar

MODEL_TYPE = TypeVar('MODEL_TYPE', bound='Model')

def get_unique_together(meta: Any): ...

class MetaInfo:
    abstract: Any = ...
    table: Any = ...
    app: Any = ...
    unique_together: Any = ...
    fields: Any = ...
    db_fields: Any = ...
    m2m_fields: Any = ...
    fk_fields: Any = ...
    backward_fk_fields: Any = ...
    fetch_fields: Any = ...
    fields_db_projection: Any = ...
    fields_db_projection_reverse: Any = ...
    filters: Any = ...
    fields_map: Any = ...
    default_connection: Any = ...
    basequery: Any = ...
    basequery_all_fields: Any = ...
    def __init__(self, meta: Any) -> None: ...
    @property
    def db(self) -> BaseDBAsyncClient: ...
    def get_filter(self, key: str) -> dict: ...
    def generate_filters(self) -> None: ...

class ModelMeta(type):
    def __new__(mcs: Any, name: str, bases: Any, attrs: dict, *args: Any, **kwargs: Any) -> Any: ...

class Model(metaclass=ModelMeta):
    id: Optional[Hashable] = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    async def save(self, *args: Any, **kwargs: Any) -> None: ...
    async def delete(self, using_db: Any=...) -> None: ...
    async def fetch_related(self, *args: Any, using_db: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    @classmethod
    async def get_or_create(cls: Type[MODEL_TYPE], using_db: Any=..., defaults: Any=..., **kwargs: Any) -> Tuple[MODEL_TYPE, bool]: ...
    @classmethod
    async def create(cls: Type[MODEL_TYPE], **kwargs: Any) -> MODEL_TYPE: ...
    @classmethod
    def first(cls: Any) -> QuerySet: ...
    @classmethod
    def filter(cls: Any, *args: Any, **kwargs: Any) -> QuerySet: ...
    @classmethod
    def exclude(cls: Any, *args: Any, **kwargs: Any) -> QuerySet: ...
    @classmethod
    def annotate(cls: Any, **kwargs: Any) -> QuerySet: ...
    @classmethod
    def all(cls: Any) -> QuerySet: ...
    @classmethod
    def get(cls: Any, *args: Any, **kwargs: Any) -> QuerySet: ...
    @classmethod
    async def fetch_for_list(cls, instance_list: Any, *args: Any, using_db: Optional[Any] = ...) -> None: ...
    @classmethod
    def check(cls) -> None: ...
    class Meta: ...
